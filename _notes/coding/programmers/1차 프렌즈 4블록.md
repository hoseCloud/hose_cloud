
#level2 #cpp #writeup  
[문제](https://school.programmers.co.kr/learn/courses/30/lessons/17679)  
template : [[template of writeup]]  

## 문제 설명  

## 프렌즈4블록  

블라인드 공채를 통과한 신입 사원 라이언은 신규 게임 개발 업무를 맡게 되었다. 이번에 출시할 게임 제목은 "프렌즈4블록".  
같은 모양의 카카오프렌즈 블록이 2×2 형태로 4개가 붙어있을 경우 사라지면서 점수를 얻는 게임이다.  

![board map](http://t1.kakaocdn.net/welcome2018/pang1.png "Friends 4 block!")  
만약 판이 위와 같이 주어질 경우, 라이언이 2×2로 배치된 7개 블록과 콘이 2×2로 배치된 4개 블록이 지워진다. 같은 블록은 여러 2×2에 포함될 수 있으며, 지워지는 조건에 만족하는 2×2 모양이 여러 개 있다면 한꺼번에 지워진다.  

![board map](http://t1.kakaocdn.net/welcome2018/pang2.png "Friends 4 block!")  

블록이 지워진 후에 위에 있는 블록이 아래로 떨어져 빈 공간을 채우게 된다.  

![board map](http://t1.kakaocdn.net/welcome2018/pang3.png "Friends 4 block!")  

만약 빈 공간을 채운 후에 다시 2×2 형태로 같은 모양의 블록이 모이면 다시 지워지고 떨어지고를 반복하게 된다.  
![board map](http://t1.kakaocdn.net/welcome2018/pang4.png "Friends 4 block!")  

위 초기 배치를 문자로 표시하면 아래와 같다.  

```  
TTTANT  
RRFACC  
RRRFCC  
TRRRAA  
TTMMMF  
TMMTTJ  
```  

각 문자는 라이언(R), 무지(M), 어피치(A), 프로도(F), 네오(N), 튜브(T), 제이지(J), 콘(C)을 의미한다  

입력으로 블록의 첫 배치가 주어졌을 때, 지워지는 블록은 모두 몇 개인지 판단하는 프로그램을 제작하라.  

### 입력 형식  

-   입력으로 판의 높이 `m`, 폭 `n`과 판의 배치 정보 `board`가 들어온다.  
-   2 ≦ `n`, `m` ≦ 30  
-   `board`는 길이 `n`인 문자열 `m`개의 배열로 주어진다. 블록을 나타내는 문자는 대문자 A에서 Z가 사용된다.  

### 출력 형식  

입력으로 주어진 판 정보를 가지고 몇 개의 블록이 지워질지 출력하라.  

## 입출력 예  

| m   | n   | board                                                          | answer |  
| --- | --- | -------------------------------------------------------------- | ------ |  
| 4   | 5   | `["CCBDE", "AAADE", "AAABF", "CCBBF"]`                         | 14     |  
| 6   | 6   | `["TTTANT", "RRFACC", "RRRFCC", "TRRRAA", "TTMMMF", "TMMTTJ"]` | 15     |  

## 풀이  

### 코드  

```  
#include <string>  
#include <vector>  
#include <algorithm>  
#define pp pair<int, int>  

using namespace std;  

int height, width;  

bool finder(int h, int w, vector<string> &blocks);  

int solution(int m, int n, vector<string> board) {  
    int answer = 0;  
    vector<pp> Q;  
    height = m;  
    width = n;  
    
    while(true) {  
        for(int h = 0; h < height; h++) {  
            for(int w = 0; w < width; w++) {  
                if(finder(h, w, board)) {  
                    answer++;  
                    Q.push_back({h, w});  
                }  
            }  
        }  
        if(Q.empty()) break;  
        while(!Q.empty()) {  
            pp p = Q.back();  
            Q.pop_back();  
            
            board[p.first][p.second] = '0';  
        }  
        
        for(int w = 0; w < width; w++) {  
            int c = 0;  
            for(int h = height-1; h >= 0; h--) {  
                swap(board[h][w], board[h+c][w]);  
                if(board[h+c][w] == '0') c++;  
            }  
        }  
    }  
    
    return answer;  
}  

bool finder(int h, int w, vector<string> &board) {  
    char target = board[h][w];  
    if(target == '0') return false;  
    
    // up-left  
    if(h != 0 && w != 0)  
        if(board[h-1][w-1] == target)  
            if(board[h-1][w] == target)  
                if(board[h][w-1] == target)  
                    return true;  
    // up-right  
    if(h != 0 && w != width-1)  
        if(board[h-1][w] == target)  
            if(board[h-1][w+1] == target)  
                if(board[h][w+1] == target)  
                    return true;  
    // down-left  
    if(h != height-1 && w != 0)  
        if(board[h][w-1] == target)  
            if(board[h+1][w-1] == target)  
                if(board[h+1][w] == target)  
                    return true;  
    // down-right  
    if(h != height-1 && w != width-1)  
        if(board[h][w+1] == target)  
            if(board[h+1][w] == target)  
                if(board[h+1][w+1] == target)  
                    return true;  
    
    return false;  
}  
```  

### 설명  

문제 설명에 적힌 내용을 그대로 코딩하면 된다. 핵심은 **블록을 어떻게 옮길 것이냐?** 이다. 아래 규칙으로 블록을 옮기는 코드를 작성했다.  

1. 사라지는 블록은 '0'으로 치환된다.  
2. 블록 바닥부터 꼭대기까지 다음을 반복한다.  
	1. 현재 위치에서 이때까지 지나친 '0'만큼(이하 c) 아래에 있는 블록과 바꾼다.  
	2. 만약 바꾼 블록이 '0'이라면 c++한다.  
3. 사라지는 블록이 없을 때까지 모든 과정을 반복한다.  

### 후기  

괜히 [[큐(Queue)]]를 쓰겠다고 삽질했다. 조금만 생각해보면 단순한 알고리즘으로 문제를 해결할 수 있었는데 너무 어렵게 생각한 것 같다.  
