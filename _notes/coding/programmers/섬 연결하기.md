
#cpp #level3 #writeup #solve_it_again  
[문제](https://school.programmers.co.kr/learn/courses/30/lessons/42861)  
template : [[template of writeup]]  

## 문제 설명  

n개의 섬 사이에 다리를 건설하는 비용(costs)이 주어질 때, 최소의 비용으로 모든 섬이 서로 통행 가능하도록 만들 때 필요한 최소 비용을 return 하도록 solution을 완성하세요.  

다리를 여러 번 건너더라도, 도달할 수만 있으면 통행 가능하다고 봅니다. 예를 들어 A 섬과 B 섬 사이에 다리가 있고, B 섬과 C 섬 사이에 다리가 있으면 A 섬과 C 섬은 서로 통행 가능합니다.  

## 제한 조건  

- 섬의 개수 n은 1 이상 100 이하입니다.  
- costs의 길이는 `((n-1) * n) / 2`이하입니다.  
- 임의의 i에 대해, costs[i][0] 와 costs[i] [1]에는 다리가 연결되는 두 섬의 번호가 들어있고, costs[i] [2]에는 이 두 섬을 연결하는 다리를 건설할 때 드는 비용입니다.  
- 같은 연결은 두 번 주어지지 않습니다. 또한 순서가 바뀌더라도 같은 연결로 봅니다. 즉 0과 1 사이를 연결하는 비용이 주어졌을 때, 1과 0의 비용이 주어지지 않습니다.  
- 모든 섬 사이의 다리 건설 비용이 주어지지 않습니다. 이 경우, 두 섬 사이의 건설이 불가능한 것으로 봅니다.  
- 연결할 수 없는 섬은 주어지지 않습니다.  

## 입출력 예  

| n   | costs                                       | return |  
| --- | ------------------------------------------- | ------ |  
| 4   | `[[0,1,1],[0,2,2],[1,2,5],[1,3,1],[2,3,8]]` | 4      |  

## 풀이  

### 코드  

```  
#include <string>  
#include <vector>  
#include <map>  
#include <unordered_map>  

using namespace std;  

int solution(int n, vector<vector<int>> costs) {  
    int answer = 0;  
    unordered_map<int, multimap<int, int>> M;    // from cost to  
    vector<bool> visited(n, false);  
    multimap<int, int> Q;  
    
    for(auto vec : costs) {  
        M[vec[0]].insert({vec[2], vec[1]});  
        M[vec[1]].insert({vec[2], vec[0]});  
    }  
    
    visited[0] = true;  
    for(auto e : M[0]) {  
        Q.insert(e);  
    }  
    
    while(--n > 0) {  
        for(auto e : Q) {  
            if(visited[e.second] == false) {  
                visited[e.second] = true;  
                for(auto f : M[e.second]) {  
                    Q.insert(f);  
                }  
                answer += e.first;  
                break;  
            }  
        }  
    }  

    return answer;  
}  
```  

### 설명  

최소비용 그래프 탐색과 그리드 문제다. 아래 규칙을 이용해 코드를 작성했다.  

1. from을 key값으로 M 추가  
2. from 0을 key값을 가지는 value값을 Q에 추가  
3. n-1번 만큼 아래를 반복  
	1. Q에 값을 순차적으로 탐색  
	2. 만약 `visited[to] == false`라면 true로 변경하고 Q에 from to를 key값을 가지는 value값을 Q에 추가  
	3. 정답에 cost만큼 추가  
	4. Q에 값을 추가했다면 continue  

### 후기  

괜히 map 쓰려다가 코드 꼬여서 삽집했다. 다음에는 간단하게 작성해보자.  
