# 2개 이하로 다른 비트

#level2 #cpp #writeup
[문제](https://school.programmers.co.kr/learn/courses/30/lessons/77885)
template : [[template of writeup]]

## 문제 설명

양의 정수 `x`에 대한 함수 `f(x)`를 다음과 같이 정의합니다.

- `x`보다 크고 `x`와 **비트가 1~2개 다른** 수들 중에서 제일 작은 수

예를 들어,

- `f(2) = 3` 입니다. 다음 표와 같이 2보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 3이기 때문입니다.

| 수  | 비트       | 다른 비트의 개수 |
| --- | ---------- | ---------------- |
| 2   | 000...0010 | 3                |
| 3   | 000.0011   | 1                |

- `f(7) = 11` 입니다. 다음 표와 같이 7보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 11이기 때문입니다.

| 수  | 비트       | 다른 비트의 개수 |
| --- | ---------- | ---------------- |
| 7   | 000...0111 |                  |
| 8   | 000...1000 | 4                |
| 9   | 000...1001 | 3                |
| 10  | 000...1010 | 3                |
| 11  | 000...1011 | 2                |

정수들이 담긴 배열 `numbers`가 매개변수로 주어집니다. `numbers`의 모든 수들에 대하여 각 수의 `f` 값을 배열에 차례대로 담아 return 하도록 solution 함수를 완성해주세요.

## 제한 조건

- 1 ≤ `numbers`의 길이 ≤ 100,000
- 0 ≤ `numbers`의 모든 수 ≤ 1015

## 입출력 예

| numbers  | result    |
| -------- | --------- |
| `[2, 7]` | `[3, 11]` |

## 풀이

### 코드

```
#include <string>
#include <vector>
#include <bitset>

using namespace std;

long long f(long long number);
long long countone(bitset<4*sizeof(long long)> &bs);

vector<long long> solution(vector<long long> numbers) {
    vector<long long> answer;
    
    for(auto number : numbers) {
        answer.push_back(f(number));
    }
    
    return answer;
}

long long f(long long number) {
    bitset<8*sizeof(long long)> comp = number;
    bitset<8*sizeof(long long)> dist = number+1;
    int diff = 0;

    comp = comp ^ dist;
    
    for(int i = 0; i < comp.size(); i++) {
        if(comp.test(i)) diff++;
    }
    
    for(int i = 0; i < diff-2; dist[i++] = 1);
    
    return dist.to_ullong();
}

```

### 설명

비트를 이용한 간단한 문제였다. 아래 규칙을 이용해 코드를 작성했다.

1. 주어진 number를 bitset으로 만든다.
2. number+1을 bitset으로 만든다.
3. 1, 2에서 만들어진 bitset을 xor하고 1의 갯수를 구한다.
4. 1의 갯수가 2개 이하가 될때까지 number+1의 bitset의 뒷자리부터 1로 설정한다.

### 후기

조금만 생각하면 쉬운 문제였는데 너무 어렵게 생각해서 오래걸렸다.
