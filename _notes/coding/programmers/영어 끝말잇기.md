
#level2 #cpp #writeup  
[문제](https://school.programmers.co.kr/learn/courses/30/lessons/12981)  
template : [[template of writeup]]  

## 문제 설명  

1부터 n까지 번호가 붙어있는 n명의 사람이 영어 끝말잇기를 하고 있습니다. 영어 끝말잇기는 다음과 같은 규칙으로 진행됩니다.  

1. 1번부터 번호 순서대로 한 사람씩 차례대로 단어를 말합니다.  
2. 마지막 사람이 단어를 말한 다음에는 다시 1번부터 시작합니다.  
3. 앞사람이 말한 단어의 마지막 문자로 시작하는 단어를 말해야 합니다.  
4. 이전에 등장했던 단어는 사용할 수 없습니다.  
5. 한 글자인 단어는 인정되지 않습니다.  

다음은 3명이 끝말잇기를 하는 상황을 나타냅니다.  

tank → kick → know → wheel → land → dream → mother → robot → tank  

위 끝말잇기는 다음과 같이 진행됩니다.  

- 1번 사람이 자신의 첫 번째 차례에 tank를 말합니다.  
- 2번 사람이 자신의 첫 번째 차례에 kick을 말합니다.  
- 3번 사람이 자신의 첫 번째 차례에 know를 말합니다.  
- 1번 사람이 자신의 두 번째 차례에 wheel을 말합니다.  
- (계속 진행)  

끝말잇기를 계속 진행해 나가다 보면, 3번 사람이 자신의 세 번째 차례에 말한 tank 라는 단어는 이전에 등장했던 단어이므로 탈락하게 됩니다.  

사람의 수 n과 사람들이 순서대로 말한 단어 words 가 매개변수로 주어질 때, 가장 먼저 탈락하는 사람의 번호와 그 사람이 자신의 몇 번째 차례에 탈락하는지를 구해서 return 하도록 solution 함수를 완성해주세요.  

## 제한 조건  

- 끝말잇기에 참여하는 사람의 수 n은 2 이상 10 이하의 자연수입니다.  
- words는 끝말잇기에 사용한 단어들이 순서대로 들어있는 배열이며, 길이는 n 이상 100 이하입니다.  
- 단어의 길이는 2 이상 50 이하입니다.  
- 모든 단어는 알파벳 소문자로만 이루어져 있습니다.  
- 끝말잇기에 사용되는 단어의 뜻(의미)은 신경 쓰지 않으셔도 됩니다.  
- 정답은 [ 번호, 차례 ] 형태로 return 해주세요.  
- 만약 주어진 단어들로 탈락자가 생기지 않는다면, [0, 0]을 return 해주세요.  

## 입출력 예  

| n   | words                                                                                                                                                                | result   |  
| --- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------- |  
| 3   | `["tank", "kick", "know", "wheel", "land", "dream", "mother", "robot", "tank"]`                                                                                      | `[3, 3]` |  
| 5   | `["hello", "observe", "effect", "take", "either", "recognize", "encourage", "ensure", "establish", "hang", "gather", "refer", "reference", "estimate", "executive"]` | `[0, 0]` |  
| 2   | `["hello", "one", "even", "never", "now", "world", "draw"]`                                                                                                          | `[1, 3]` |  

## 풀이  

### 코드  

```  
#include <string>  
#include <vector>  
#include <iostream>  

using namespace std;  

vector<int> solution(int n, vector<string> words) {  
    vector<int> answer;  
    vector<vector<string>> list(26);  
    char prev = words[0][0];  
    int turn = 1, count = 1;  
    bool flag = false;  
    
    for(auto word : words) {  
        if(count > n) {  
            turn++;  
            count = 1;  
        }  
        
        if(prev != word[0]) {  
            flag = true;  
            break;  
        }  
        
        for(auto test : list[word[0]-'a']) {  
            if(test == word) {  
                flag = true;  
                break;  
            }  
        }  
        if(flag) break;  
        
        prev = word[word.size()-1];  
        list[word[0]-'a'].push_back(word);  
        count++;  
    }  
    
    if(flag) {  
        answer.push_back(count);  
        answer.push_back(turn);  
    }  
    else {  
        answer.push_back(0);  
        answer.push_back(0);  
    }  

    return answer;  
}  
```  

### 설명  

주어진 단어를 처음부터 끝까지 검사한다. 통과된 단어는 `vector<vector<string>> list(26)`에 저장한다. 시간복잡도를 생각해서 시작하는 알파벳을 인덱스로 저장한다.  

1. 주어진 단어가 전 단어와 이어지는지 확인한다.  
2. 주어진 단어가 list에 있는지 확인한다.  
3. 모든 단어를 확인할 때까지 위 과정을 반복한다. 만약 모든 단어를 확인하고 반복문이 끝난다면 `[0, 0]`을 출력한다.  

반복문이 돌아가는 중에 누구의 차례이고 몇번째 차례인지 동시에 계산한다. 이 과정은 간단하기 때문에 따로 설명하지 않았다.  

### 후기  

다른 사람의 풀이에서 map을 이용한 풀이가 있었다. 다음에는 STL의 map을 이용해서 풀어봐야겠다.  
