# 단속카메라

#level3 #cpp #writeup
[문제](https://school.programmers.co.kr/learn/courses/30/lessons/42884)
template : [[template of writeup]]

## 문제 설명

고속도로를 이동하는 모든 차량이 고속도로를 이용하면서 단속용 카메라를 한 번은 만나도록 카메라를 설치하려고 합니다.

고속도로를 이동하는 차량의 경로 routes가 매개변수로 주어질 때, 모든 차량이 한 번은 단속용 카메라를 만나도록 하려면 최소 몇 대의 카메라를 설치해야 하는지를 return 하도록 solution 함수를 완성하세요.

## 제한 조건

- 차량의 대수는 1대 이상 10,000대 이하입니다.
- routes에는 차량의 이동 경로가 포함되어 있으며 routes[i][0]에는 i번째 차량이 고속도로에 진입한 지점, routes[i][1]에는 i번째 차량이 고속도로에서 나간 지점이 적혀 있습니다.
- 차량의 진입/진출 지점에 카메라가 설치되어 있어도 카메라를 만난것으로 간주합니다.
- 차량의 진입 지점, 진출 지점은 -30,000 이상 30,000 이하입니다.

## 입출력 예

| routes                                      | return |
| ------------------------------------------- | ------ |
| `[[-20,-15], [-14,-5], [-18,-13], [-5,-3]]` | 2      |

## 풀이

### 코드

```
#include <string>
#include <vector>
#include <queue>
#include <algorithm>

using namespace std;

int solution(vector<vector<int>> routes) {
    int answer = 0;
    priority_queue<int, vector<int>, greater<int>> Q;
    
    sort(routes.begin(), routes.end(), greater());
    
    while(!routes.empty() || !Q.empty()) { 
        int rmin = routes.empty() ? 99999 : routes.back()[0];
        int qmin = Q.empty() ? 99999 : Q.top();
        
        if(rmin < qmin) {
            Q.push(routes.back()[1]);
            routes.pop_back();
        }
        else if(rmin > qmin) {
            Q = {};
            answer++;
        }
        else {  // rmin == qmin
            Q = {};
            answer++;
            routes.pop_back();
        }
    }
    
    return answer;
}
```

### 설명

[[우선순위 큐(Priority Queue)]]를 이용해 문제를 해결했다. 아래 규칙을 이용해 코드를 작성했다.

1. routes를 출입지점을 기준으로 오름차순 정렬한다.
2. routes와 Q가 빌때까지 아래 과정을 반복한다.
	1. `rmin = routes.back()[0]`과 `qmin = Q.top()`을 비교한다.
	2. rmin이 작다면 Q에 `routes.back()[1]`을 push하고 routes를 pop_back한다.
	3. qmin이 작다면 Q를 모두 비우고 answer++한다.
	4. 서로 같다면 Q를 모두 비우고 answer++ 하고 routes를 pop_back한다.

### 후기

우선순위 큐를 사용하지 않고 정렬만으로 문제를 해결한 사람이 있다.

```
#include <bits/stdc++.h>
using namespace std;

bool cmp(vector<int> a, vector<int> b) { return a[1] < b[1]; }

int solution(vector<vector<int>> routes) {
    int answer = 0;
    int limit = -30001;
    sort(routes.begin(), routes.end(), cmp);
    for(int i = 0; i < routes.size(); i++){
        if(limit < routes[i][0]){
            answer++;
            limit = routes[i][1];
        }
    }
    return answer;
}
```

이 코드를 작성한 사람들은 무슨 괴물들인가... 항상 이쁘고 좋은 코드들을 작성해 놓는다.
