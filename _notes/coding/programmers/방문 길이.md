
#level2 #cpp #writeup
[문제](https://school.programmers.co.kr/learn/courses/30/lessons/49994)
template : [[template of writeup]]

## 문제 설명

게임 캐릭터를 4가지 명령어를 통해 움직이려 합니다. 명령어는 다음과 같습니다.

- U: 위쪽으로 한 칸 가기
- D: 아래쪽으로 한 칸 가기
- R: 오른쪽으로 한 칸 가기
- L: 왼쪽으로 한 칸 가기

캐릭터는 좌표평면의 (0, 0) 위치에서 시작합니다. 좌표평면의 경계는 왼쪽 위(-5, 5), 왼쪽 아래(-5, -5), 오른쪽 위(5, 5), 오른쪽 아래(5, -5)로 이루어져 있습니다.

![방문길이1_qpp9l3.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/ace0e7bc-9092-4b95-9bfb-3a55a2aa780e/%E1%84%87%E1%85%A1%E1%86%BC%E1%84%86%E1%85%AE%E1%86%AB%E1%84%80%E1%85%B5%E1%86%AF%E1%84%8B%E1%85%B51_qpp9l3.png)

예를 들어, "ULURRDLLU"로 명령했다면

![방문길이2_lezmdo.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/668c7458-e184-472d-9d32-f5d2acca759a/%E1%84%87%E1%85%A1%E1%86%BC%E1%84%86%E1%85%AE%E1%86%AB%E1%84%80%E1%85%B5%E1%86%AF%E1%84%8B%E1%85%B52_lezmdo.png)

- 1번 명령어부터 7번 명령어까지 다음과 같이 움직입니다.

![방문길이3_sootjd.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/08558e36-d667-4160-bfec-b754c78a7d85/%E1%84%87%E1%85%A1%E1%86%BC%E1%84%86%E1%85%AE%E1%86%AB%E1%84%80%E1%85%B5%E1%86%AF%E1%84%8B%E1%85%B53_sootjd.png)

- 8번 명령어부터 9번 명령어까지 다음과 같이 움직입니다.

![방문길이4_hlpiej.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/a52af28e-5835-438b-9f40-5467ebf9bf03/%E1%84%87%E1%85%A1%E1%86%BC%E1%84%86%E1%85%AE%E1%86%AB%E1%84%80%E1%85%B5%E1%86%AF%E1%84%8B%E1%85%B54_hlpiej.png)

이때, 우리는 게임 캐릭터가 지나간 길 중 **캐릭터가 처음 걸어본 길의 길이**를 구하려고 합니다. 예를 들어 위의 예시에서 게임 캐릭터가 움직인 길이는 9이지만, 캐릭터가 처음 걸어본 길의 길이는 7이 됩니다. (8, 9번 명령어에서 움직인 길은 2, 3번 명령어에서 이미 거쳐 간 길입니다)

단, 좌표평면의 경계를 넘어가는 명령어는 무시합니다.

예를 들어, "LULLLLLLU"로 명령했다면

![방문길이5_nitjwj.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/f631f005-f8de-4392-a76c-a9ef64b6de08/%E1%84%87%E1%85%A1%E1%86%BC%E1%84%86%E1%85%AE%E1%86%AB%E1%84%80%E1%85%B5%E1%86%AF%E1%84%8B%E1%85%B55_nitjwj.png)

- 1번 명령어부터 6번 명령어대로 움직인 후, 7, 8번 명령어는 무시합니다. 다시 9번 명령어대로 움직입니다.

![방문길이6_nzhumd.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/35e62f0a-43c6-4142-bec6-6d28fbc57216/%E1%84%87%E1%85%A1%E1%86%BC%E1%84%86%E1%85%AE%E1%86%AB%E1%84%80%E1%85%B5%E1%86%AF%E1%84%8B%E1%85%B56_nzhumd.png)

이때 캐릭터가 처음 걸어본 길의 길이는 7이 됩니다.

명령어가 매개변수 dirs로 주어질 때, 게임 캐릭터가 처음 걸어본 길의 길이를 구하여 return 하는 solution 함수를 완성해 주세요.

## 제한 조건

- dirs는 string형으로 주어지며, 'U', 'D', 'R', 'L' 이외에 문자는 주어지지 않습니다.
- dirs의 길이는 500 이하의 자연수입니다.

## 입출력 예

| dirs        | answer |
| ----------- | ------ |
| "ULURRDLLU" | 7      |
| "LULLLLLLU" | 7      |

## 풀이

### 코드

```
#include <string>
#include <iostream>

using namespace std;

struct Cor {
    int x = 5;
    int y = 5;
};
struct Line {
    bool width[11][10] = {false, };
    bool height[11][10] = {false, };
};

bool move(char& dir, Cor& cor);
bool tracking(char& dir, Cor& cor, Line& line);

int solution(string dirs) {
    int answer = 0;
    Cor cor;
    Line line;
    
    for(auto dir : dirs) {
        if(!move(dir, cor)) continue;
        if(tracking(dir, cor, line)) answer++;
    }
    
    return answer;
}

bool move(char& dir, Cor& cor) {
    if(dir == 'U') {
        if(cor.y != 10) {
            cor.y++;
            return true;
        }
    }
    else if(dir == 'D') {
        if(cor.y != 0) {
            cor.y--;
            return true;
        }
    }
    else if(dir == 'R') {
        if(cor.x != 10) {
            cor.x++;
            return true;
        }
    }
    else if(dir == 'L') {
        if(cor.x != 0) {
            cor.x--;
            return true;
        }
    }
    
    return false;
}
bool tracking(char& dir, Cor& cor, Line &line) {
    
    if(dir == 'U') {
        // 0 0 -> 0 1 : 0 0
        bool& target = line.height[cor.x][cor.y-1];
        if(target) return false;
        else target = true;
    }
    else if(dir == 'D') {
        // 0 1 -> 0 0 : 0 0
        bool& target = line.height[cor.x][cor.y];
        if(target) return false;
        else target = true;
    }
    else if(dir == 'R') {
        // 0 0 -> 1 0 : 0 0
        bool& target = line.width[cor.y][cor.x-1];
        if(target) return false;
        else target = true;
    }
    else if(dir == 'L') {
        // 1 0 -> 0 0 : 0 0
        bool& target = line.width[cor.y][cor.x];
        if(target) return false;
        else target = true;
    }
    return true;
}
```

### 설명

함수형 프로그래밍으로 코드를 작성했다.
시작점을 (0,0)대신 (5,5)로, 좌표평면 최좌하단의 좌표를 (0,0)으로 가정한다. 지나간 길을 표시하기 위해 bool형 배열을 선언했다.
