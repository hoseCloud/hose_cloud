
#level2 #cpp #writeup  
[문제](https://school.programmers.co.kr/learn/courses/30/lessons/12913)  
template : [[template of writeup]]  

## 문제 설명  

땅따먹기 게임을 하려고 합니다. 땅따먹기 게임의 땅(land)은 총 N행 4열로 이루어져 있고, 모든 칸에는 점수가 쓰여 있습니다. 1행부터 땅을 밟으며 한 행씩 내려올 때, 각 행의 4칸 중 한 칸만 밟으면서 내려와야 합니다. **단, 땅따먹기 게임에는 한 행씩 내려올 때, 같은 열을 연속해서 밟을 수 없는 특수 규칙이 있습니다.**  

예를 들면,  

| 1 | 2 | 3 | 5 |  

| 5 | 6 | 7 | 8 |  

| 4 | 3 | 2 | 1 |  

로 땅이 주어졌다면, 1행에서 네번째 칸 (5)를 밟았으면, 2행의 네번째 칸 (8)은 밟을 수 없습니다.  

마지막 행까지 모두 내려왔을 때, 얻을 수 있는 점수의 최대값을 return하는 solution 함수를 완성해 주세요. 위 예의 경우, 1행의 네번째 칸 (5), 2행의 세번째 칸 (7), 3행의 첫번째 칸 (4) 땅을 밟아 16점이 최고점이 되므로 16을 return 하면 됩니다.  

## 제한 조건  

- 행의 개수 N : 100,000 이하의 자연수  
- 열의 개수는 4개이고, 땅(land)은 2차원 배열로 주어집니다.  
- 점수 : 100 이하의 자연수  

## 입출력 예  

| land                              | answer |  
| --------------------------------- | ------ |  
| `[[1,2,3,5],[5,6,7,8],[4,3,2,1]]` | 16     |  

## 풀이  

### 코드  

```  
#include <vector>  

using namespace std;  

int ex1max(int index, vector<int> target);  

int solution(vector<vector<int>> land) {  
    int answer = 0;  
    vector<int> prev(4, 0);  
    vector<int> curt;  
    
    for(int i = 0; i < land.size(); i++) {  
        for(int j = 0; j < land[0].size(); j++) {  
            curt.push_back(ex1max(j, prev) + land[i][j]);  
        }  
        prev = curt;  
        curt.clear();  
    }  
    answer = ex1max(-1, prev);  

    return answer;  
}  

int ex1max(int index, vector<int> target) {  
    int result = -1;  
    
    for(int i = 0; i < target.size(); i++) {  
        if(i == index) continue;  
        if(target[i] > result) result = target[i];  
    }  
    
    return result;  
}  
```  

### 설명  

[[동적 계획법(Dynamic Programming)]] 문제이다. 핵심은 **어느 지점에서의 최댓값은 이전 지점에서의 최댓값에서 오는 경로이다.** 연속된 행을 경로로 할 수 없다는 조건 때문에 DP 문제가 된다.  

![[땅따먹기.png]]  
