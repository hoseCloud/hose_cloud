
#level3 #cpp #writeup  
[문제](https://school.programmers.co.kr/learn/courses/30/lessons/43163)  
template : [[template of writeup]]  

## 문제 설명  

두 개의 단어 begin, target과 단어의 집합 words가 있습니다. 아래와 같은 규칙을 이용하여 begin에서 target으로 변환하는 가장 짧은 변환 과정을 찾으려고 합니다.  

```  
1. 한 번에 한 개의 알파벳만 바꿀 수 있습니다.  
2. words에 있는 단어로만 변환할 수 있습니다.  
```  

예를 들어 begin이 "hit", target가 "cog", words가 `["hot","dot","dog","lot","log","cog"]`라면 "hit" -> "hot" -> "dot" -> "dog" -> "cog"와 같이 4단계를 거쳐 변환할 수 있습니다.  

두 개의 단어 begin, target과 단어의 집합 words가 매개변수로 주어질 때, 최소 몇 단계의 과정을 거쳐 begin을 target으로 변환할 수 있는지 return 하도록 solution 함수를 작성해주세요.  

## 제한 조건  

- 각 단어는 알파벳 소문자로만 이루어져 있습니다.  
- 각 단어의 길이는 3 이상 10 이하이며 모든 단어의 길이는 같습니다.  
- words에는 3개 이상 50개 이하의 단어가 있으며 중복되는 단어는 없습니다.  
- begin과 target은 같지 않습니다.  
- 변환할 수 없는 경우에는 0를 return 합니다.  

## 입출력 예  

| begin | target | words                                        | return |  
| ----- | ------ | -------------------------------------------- | ------ |  
| "hit" | "cog"  | `["hot", "dot", "dog", "lot", "log", "cog"]` | 4      |  
| "hit" | "cog"  | `["hot", "dot", "dog", "lot", "log"]`        | 0      |  

## 풀이  

### 코드  

```  
#include <string>  
#include <vector>  
#include <queue>  
#include <algorithm>  

using namespace std;  

string remove1str(string &str, int size, int index);  
bool similar(string &a, string b, int size);  

int solution(string begin, string target, vector<string> words) {  
    int size = begin.size();  
    queue<string> bfs;  
    
    bfs.push(begin);  
    bfs.push("FLAG");  
    
    for(int depth = 1; bfs.front() != "FLAG"; depth++) {  
        do {  
            string current = bfs.front();  
            bfs.pop();  
            
            queue<string> trash;  
            for(auto word : words) {  
                if(similar(current, word, size)) {  
                    if(word == target) {  
                        return depth;  
                    }  
                    bfs.push(word);  
                    trash.push(word);  
                }  
            }  
            while(!trash.empty()) {  
                words.erase(find(words.begin(), words.end(), trash.front()));  
                trash.pop();  
            }  
        } while(bfs.front() != "FLAG");  

        bfs.pop();  
        bfs.push("FLAG");  
    }  
    
    return 0;  
}  

string remove1str(string &str, int size, int index) {  
    string result = "";  
    
    result += str.substr(0, index);  
    result += str.substr(index+1, str.size()-1-index);  
    
    return result;  
}  
bool similar(string &a, string b, int size) {  
    bool result = false;  
    
    for(int i = 0; i < size; i++) {  
        string sa = remove1str(a, size, i);  
        string sb = remove1str(b, size, i);  
        
        if(sa == sb) {  
            result = true;  
            break;  
        }  
    }  
    
    return result;  
}  
```  

### 설명  

[[큐(Queue)]]를 이용한 BFS로 문제를 해결했다. 아래 규칙으로 코드를 작성했다.  

1. 큐에 begin과 FLAG를 push한다.  
2. 큐에 있는 값을 pop하고 words에 비슷한 단어가 있는지 비교한다. 만약 있다면 큐에 넣고 words에서 제거한다.  
3. 만약 큐에 있는 값이 FLAG라면 pop후 FLAG를 push한다.  
4. 만약 큐에 있는 값이 FLAG라면 정답은 0이다. 아니라면 규칙 2~4를 반복한다.  

BFS를 사용한 이유는 아래와 같다.  

- 대상 노드를 통과하는 노드들은 결국 같은 값(word)이 된다. 즉, 대상 노드를 통과하면 이 후 경로는 항상 같다.  
- 항상 짧은 경로만 검사하면 된다.  

![[단어 변환.gif]]  

### 후기  

BFS를 오랜만에 해봐서 어떻게 코드를 작성했는지 기억이 잘 안나서 오래걸렸다.  
