# 등굣길

#level3 #cpp #writeup
[문제](https://school.programmers.co.kr/learn/courses/30/lessons/42898)
template : [[template of writeup]]

## 문제 설명

계속되는 폭우로 일부 지역이 물에 잠겼습니다. 물에 잠기지 않은 지역을 통해 학교를 가려고 합니다. 집에서 학교까지 가는 길은 m x n 크기의 격자모양으로 나타낼 수 있습니다.

아래 그림은 m = 4, n = 3 인 경우입니다.
  
![image0.png](https://grepp-programmers.s3.amazonaws.com/files/ybm/056f54e618/f167a3bc-e140-4fa8-a8f8-326a99e0f567.png)

가장 왼쪽 위, 즉 집이 있는 곳의 좌표는 (1, 1)로 나타내고 가장 오른쪽 아래, 즉 학교가 있는 곳의 좌표는 (m, n)으로 나타냅니다.

격자의 크기 m, n과 물이 잠긴 지역의 좌표를 담은 2차원 배열 puddles이 매개변수로 주어집니다. **오른쪽과 아래쪽으로만 움직여** 집에서 학교까지 갈 수 있는 최단경로의 개수를 1,000,000,007로 나눈 나머지를 return 하도록 solution 함수를 작성해주세요.

## 제한 조건

- 격자의 크기 m, n은 1 이상 100 이하인 자연수입니다.
    - m과 n이 모두 1인 경우는 입력으로 주어지지 않습니다.
- 물에 잠긴 지역은 0개 이상 10개 이하입니다.
- 집과 학교가 물에 잠긴 경우는 입력으로 주어지지 않습니다.

## 입출력 예

| m   | n   | puddles    | return |
| --- | --- | ---------- | ------ |
| 4   | 3   | `[[2, 2]]` | 4      |

## 풀이

### 코드

```
#include <string>
#include <vector>

using namespace std;

int dp[101][101];

int solution(int m, int n, vector<vector<int>> puddles) {
    int answer = 0;
    
    dp[1][0] = 1;
    
    for(auto puddle : puddles) {
        int x = puddle[0];
        int y = puddle[1];
        
        dp[x][y] = -1;
    }
    
    for(int y = 1; y <= n; y++) {
        for(int x = 1; x <= m; x++) {
            if(dp[x][y] == -1) continue;
            
            int top = dp[x][y-1] > 0 ? dp[x][y-1] : 0;
            int left = dp[x-1][y] > 0 ? dp[x-1][y] : 0;
            
            dp[x][y] = (top + left) % 1000000007;
        }
    }
    
    answer = dp[m][n] % 1000000007;
    
    return answer;
}
```

### 설명

[[동적 계획법(Dynamic Programming)]]을 이용해 문제를 해결했다. 핵심은 **한 지점은 윗쪽과 왼쪽에서만 올 수 있다는 점**이다. 다음 지점으로 가기 위해서는 이전의 경로가 모두 통과할 수 있다. 즉, 한 지점에서의 경로는 윗쪽 경로의 수와 왼쪽 경로의 수의 합이다.
