
#cpp #level2 #writeup #solve_it_again 
[문제](https://school.programmers.co.kr/learn/courses/30/lessons/67257#)
template : [[template of writeup]]

## 문제 설명

IT 벤처 회사를 운영하고 있는 `라이언`은 매년 사내 해커톤 대회를 개최하여 우승자에게 상금을 지급하고 있습니다.  
이번 대회에서는 우승자에게 지급되는 상금을 이전 대회와는 다르게 다음과 같은 방식으로 결정하려고 합니다.  
해커톤 대회에 참가하는 모든 참가자들에게는 숫자들과 3가지의 연산문자(`+, -, *`) 만으로 이루어진 연산 수식이 전달되며, 참가자의 미션은 전달받은 수식에 포함된 연산자의 우선순위를 자유롭게 재정의하여 만들 수 있는 가장 큰 숫자를 제출하는 것입니다.  
단, 연산자의 우선순위를 새로 정의할 때, 같은 순위의 연산자는 없어야 합니다. 즉, `+` > `-` > `*` 또는 `-` > `*` > `+` 등과 같이 연산자 우선순위를 정의할 수 있으나 `+,*` > `-` 또는 `*` > `+,-`처럼 2개 이상의 연산자가 동일한 순위를 가지도록 연산자 우선순위를 정의할 수는 없습니다. 수식에 포함된 연산자가 2개라면 정의할 수 있는 연산자 우선순위 조합은 2! = 2가지이며, 연산자가 3개라면 3! = 6가지 조합이 가능합니다.  
만약 계산된 결과가 음수라면 해당 숫자의 절댓값으로 변환하여 제출하며 제출한 숫자가 가장 큰 참가자를 우승자로 선정하며, 우승자가 제출한 숫자를 우승상금으로 지급하게 됩니다.

예를 들어, 참가자 중 `네오`가 아래와 같은 수식을 전달받았다고 가정합니다.

`"100-200*300-500+20"`

일반적으로 수학 및 전산학에서 약속된 연산자 우선순위에 따르면 더하기와 빼기는 서로 동등하며 곱하기는 더하기, 빼기에 비해 우선순위가 높아 `*` > `+,-` 로 우선순위가 정의되어 있습니다.  
대회 규칙에 따라 `+` > `-` > `*` 또는 `-` > `*` > `+` 등과 같이 연산자 우선순위를 정의할 수 있으나 `+,*` > `-` 또는 `*` > `+,-` 처럼 2개 이상의 연산자가 동일한 순위를 가지도록 연산자 우선순위를 정의할 수는 없습니다.  
수식에 연산자가 3개 주어졌으므로 가능한 연산자 우선순위 조합은 3! = 6가지이며, 그 중 `+` > `-` > `*` 로 연산자 우선순위를 정한다면 결괏값은 22,000원이 됩니다.  
반면에 `*` > `+` > `-` 로 연산자 우선순위를 정한다면 수식의 결괏값은 -60,420 이지만, 규칙에 따라 우승 시 상금은 절댓값인 60,420원이 됩니다.

참가자에게 주어진 연산 수식이 담긴 문자열 expression이 매개변수로 주어질 때, 우승 시 받을 수 있는 가장 큰 상금 금액을 return 하도록 solution 함수를 완성해주세요.

## 제한 조건

- expression은 길이가 3 이상 100 이하인 문자열입니다.
- expression은 공백문자, 괄호문자 없이 오로지 숫자와 3가지의 연산자(`+, -, *`) 만으로 이루어진 올바른 중위표기법(연산의 두 대상 사이에 연산기호를 사용하는 방식)으로 표현된 연산식입니다. 잘못된 연산식은 입력으로 주어지지 않습니다.
    - 즉, `"402+-561*"`처럼 잘못된 수식은 올바른 중위표기법이 아니므로 주어지지 않습니다.  
        
- expression의 피연산자(operand)는 0 이상 999 이하의 숫자입니다.
    - 즉, `"100-2145*458+12"`처럼 999를 초과하는 피연산자가 포함된 수식은 입력으로 주어지지 않습니다.
    - `"-56+100"`처럼 피연산자가 음수인 수식도 입력으로 주어지지 않습니다.
- expression은 적어도 1개 이상의 연산자를 포함하고 있습니다.
- 연산자 우선순위를 어떻게 적용하더라도, expression의 중간 계산값과 최종 결괏값은 절댓값이 $2^{63}$ - 1 이하가 되도록 입력이 주어집니다.
- 같은 연산자끼리는 앞에 있는 것의 우선순위가 더 높습니다.

## 입출력 예

| expression             | result |
| ---------------------- | ------ |
| `"100-200*300-500+20"` | 60420  |
| `"50*6-3*2"`             | 300       |

## 풀이

### 코드

```
#include <string>
#include <vector>
#include <queue>
#include <map>
#include <algorithm>

using namespace std;

queue<string> make_post_fix(string expression, map<string, int> M) {
    queue<string> Q;
    vector<string> S;
    string number, s;
    
    for(auto e : expression) {
        if(isdigit(e)) {
            number.push_back(e);
        }
        else {
            if(!number.empty()) {
                Q.push(number);
                number.clear();
            }
            
            s = e;
            if(S.empty() || M[S.back()] < M[s]) {
                S.push_back(s);
            }
            else {
                while(!S.empty() && M[S.back()] >= M[s]) {
                    Q.push(S.back());
                    S.pop_back();
                }
                S.push_back(s);
            }
        }
    }
    
    if(!number.empty()) {
        Q.push(number);
    }
    while(!S.empty()) {
        Q.push(S.back());
        S.pop_back();
    }
    
    return Q;
}

string calc_op(string a, string op, string b) {
    long long A, B, result;
    
    A = stoll(a);
    B = stoll(b);
    
    if(op == "+") {
        result = A + B;
    }
    else if(op == "-") {
        result = A - B;
    }
    else if(op == "*") {
        result = A * B;
    }
    
    return to_string(result);
}
long long calc_post_fix(queue<string> Q) {
    vector<string> S;
    string s;
    
    while(!Q.empty()) {
        s = Q.front();  Q.pop();
        
        if(isdigit(s[0])) {
            S.push_back(s);
        }
        else {
            string a, b;
            
            b = S.back();   S.pop_back();
            a = S.back();   S.pop_back();
            s = calc_op(a, s, b);
            
            S.push_back(s);
        }
    }
    
    return stoll(S.back());
}

long long solution(string expression) {
    long long answer = 0;
    long long result;
    string op = "*+-";
    string s;
    queue<string> Q;
    map<string, int> M;
    
    do {
        M.clear();
        for(int i = 0; i < op.size(); i++) {
            s = op[i];
            M[s] = i;
        }
        Q = make_post_fix(expression, M);
        result = calc_post_fix(Q);
        
        answer = max(answer, abs(result));
    } while(next_permutation(op.begin(), op.end()));
    
    return answer;
}
```

### 설명

주어진 표현식을 [[후위연산식(postfix expression)]]으로 변환해 문제를 해결했다. 아래 규칙을 이용해 코드를 작성했다.

1. map에 연산 우선순위를 저장
2. queue에 주어진 표현식을 후위연삭식으로 저장
3. queue를 이용해 후위연산식을 계산
4. 계산한 값 중에 가장 큰 값이 answer

### 후기

문제를 딱 보자마자 후위연산식이 떠올랐다. 막상 코드를 짤려니 후위연삭식이 기억이 안나 구글링하는데 시간을 쫌 보냈다. 같은 연산자에 대한 처리를 늦게 발견해서 삽질도 했다.

다음에는 코드를 더 간결하게 작성해보자. 목표는 sstream 사용!
