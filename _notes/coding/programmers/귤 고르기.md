
#cpp #level2 #writeup  
[문제](https://school.programmers.co.kr/learn/courses/30/lessons/138476)  
template : [[template of writeup]]  

## 문제 설명  

경화는 과수원에서 귤을 수확했습니다. 경화는 수확한 귤 중 'k'개를 골라 상자 하나에 담아 판매하려고 합니다. 그런데 수확한 귤의 크기가 일정하지 않아 보기에 좋지 않다고 생각한 경화는 귤을 크기별로 분류했을 때 서로 다른 종류의 수를 최소화하고 싶습니다.  

예를 들어, 경화가 수확한 귤 8개의 크기가 `[1, 3, 2, 5, 4, 5, 2, 3]` 이라고 합시다. 경화가 귤 6개를 판매하고 싶다면, 크기가 1, 4인 귤을 제외한 여섯 개의 귤을 상자에 담으면, 귤의 크기의 종류가 2, 3, 5로 총 3가지가 되며 이때가 서로 다른 종류가 최소일 때입니다.  

경화가 한 상자에 담으려는 귤의 개수 `k`와 귤의 크기를 담은 배열 `tangerine`이 매개변수로 주어집니다. 경화가 귤 k개를 고를 때 크기가 서로 다른 종류의 수의 최솟값을 return 하도록 solution 함수를 작성해주세요.  

## 제한 조건  

- 1 ≤ `k` ≤ `tangerine`의 길이 ≤ 100,000  
- 1 ≤ `tangerine`의 원소 ≤ 10,000,000  

## 입출력 예  

| k   | tangerine                  | result |  
| --- | -------------------------- | ------ |  
| 6   | `[1, 3, 2, 5, 4, 5, 2, 3]` | 3      |  
| 4   | `[1, 3, 2, 5, 4, 5, 2, 3]` | 2      |  
| 2   | `[1, 1, 1, 1, 2, 2, 2, 3]` | 1      |  

## 풀이  

### 코드  

```  
#include <string>  
#include <vector>  
#include <map>  
#include <algorithm>  

using namespace std;  

int solution(int k, vector<int> tangerine) {  
    int answer = 0;  
    map<int, int> box;  
    vector<int> v;  
    
    for(auto e : tangerine) {  
        box[e]++;  
    }  
    
    for(auto e : box) {  
        v.push_back(e.second);  
    }  
    
    sort(v.begin(), v.end(), greater());  
    
    for(auto e : v) {  
        k -= e;  
        answer++;  
        
        if(k <= 0) {  
            break;  
        }  
    }  
    
    return answer;  
}  
```  

### 설명  

같은 크기의 귤을 가장 많이 넣으면 되는 문제다. 최대한 크기의 종류가 적어야 하기 때문에 같은 크기의 가장 많은 귤을 넣으면 된다. 아래 규칙을 이용해 코드를 작성했다.  

1. map에 귤의 크기와 개수를 insert  
2. vector에 map의 귤의 개수를 push_back  
3. vector를 greater로 sort  
4. vector 순서대로 k에 빼고 answer++  
5. 만약 k가 0보다 작거나 같아지면 return  
6. 아니라면 4번부터 다시 반복  
