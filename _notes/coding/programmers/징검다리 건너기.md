
#level3 #cpp #writeup
[문제](https://school.programmers.co.kr/learn/courses/30/lessons/64062)
template : [[template of writeup]]

## 문제 설명

**`[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]`**

카카오 초등학교의 "니니즈 친구들"이 "라이언" 선생님과 함께 가을 소풍을 가는 중에 **징검다리**가 있는 개울을 만나서 건너편으로 건너려고 합니다. "라이언" 선생님은 "니니즈 친구들"이 무사히 징검다리를 건널 수 있도록 다음과 같이 규칙을 만들었습니다.

- 징검다리는 일렬로 놓여 있고 각 징검다리의 디딤돌에는 모두 숫자가 적혀 있으며 디딤돌의 숫자는 한 번 밟을 때마다 1씩 줄어듭니다.
- 디딤돌의 숫자가 0이 되면 더 이상 밟을 수 없으며 이때는 그 다음 디딤돌로 한번에 여러 칸을 건너 뛸 수 있습니다.
- 단, 다음으로 밟을 수 있는 디딤돌이 여러 개인 경우 무조건 가장 가까운 디딤돌로만 건너뛸 수 있습니다.

"니니즈 친구들"은 개울의 왼쪽에 있으며, 개울의 오른쪽 건너편에 도착해야 징검다리를 건넌 것으로 인정합니다.  
"니니즈 친구들"은 한 번에 한 명씩 징검다리를 건너야 하며, 한 친구가 징검다리를 모두 건넌 후에 그 다음 친구가 건너기 시작합니다.

디딤돌에 적힌 숫자가 순서대로 담긴 배열 stones와 한 번에 건너뛸 수 있는 디딤돌의 최대 칸수 k가 매개변수로 주어질 때, 최대 몇 명까지 징검다리를 건널 수 있는지 return 하도록 solution 함수를 완성해주세요.

## 제한 조건

- 징검다리를 건너야 하는 니니즈 친구들의 수는 무제한 이라고 간주합니다.
- stones 배열의 크기는 1 이상 200,000 이하입니다.
- stones 배열 각 원소들의 값은 1 이상 200,000,000 이하인 자연수입니다.
- k는 1 이상 stones의 길이 이하인 자연수입니다.

## 입출력 예

| stones                           | k   | result |
| -------------------------------- | --- | ------ |
| `[2, 4, 5, 3, 2, 1, 4, 2, 5, 1]` | 3   | 3      |

## 풀이

### 코드

```
#include <string>
#include <vector>
using namespace std;

bool check(const vector<int> &vec, const int k, const int n);

int solution(vector<int> stones, int k) {
    int start, mid, end;
    start = 1, end = 200000000, mid = (start+end)/2;

    while(end-start != 1) {

        if(check(stones, k, mid)) {
            start = mid;
        }
        else {
            end = mid;
        }

        mid = (start+end)/2;
    }

    return check(stones, k, end) ? end : start;
}

bool check(const vector<int> &vec, const int k, const int n) {
    int count = 0;

    for(auto e : vec)
        if(e < n) {
            if(++count >= k) {
                return false;
            }
        }  
        else {
            count = 0;
        }

    return true;
}
```

### 설명

이분탐색을 이용해 문제를 해결했다. 아래 규칙을 이용해 코드를 작성했다.

1. 몇 명의 사람이 건널 수 있는지 이분탐색으로 아래를 반복
	1. mid = (start+end)/2
	2. mid의 인원이 다리를 건널 수 있는지 확인
	3. 만약 가능하다면 start = mid, 아니라면 end = mid
	4. end-start != 1일 때까지 반복
2. end의 인원이 다리를 건널 수 있다면 정답은 end 아니라면 start

### 후기

sliding-window-maximum 방식을 이용해 처음 문제를 해결하려 했다. 하지만 최악의 케이스에서 효율성 검사를 통과하지 못했다. 다른 사람의 풀이를 보니 muitiset을 이용해 문제를 해결할 수 있었다.
